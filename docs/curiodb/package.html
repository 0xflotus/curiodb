<!DOCTYPE html >
<html>
        <head>
          <title>curiodb - curiodb</title>
          <meta name="description" content="curiodb - curiodb" />
          <meta name="keywords" content="curiodb curiodb" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../lib/template.js"></script>
      <script type="text/javascript" src="../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../index.html';
            var hash = 'curiodb.package';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="value">
      <div id="definition">
        <img alt="Package" src="../lib/package_big.png" />
        
        <h1>curiodb</h1><span class="permalink">
      <a href="../index.html#curiodb.package" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">curiodb</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        
        
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="curiodb.Aggregate" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="Aggregate[T]extendsActorwithCommandProcessingwithActorLogging"></a>
      <a id="Aggregate[T]:Aggregate[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="Aggregate.html"><span class="name">Aggregate</span></a><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <span class="extype" name="akka.actor.Actor">Actor</span> with <a href="CommandProcessing.html" class="extype" name="curiodb.CommandProcessing">CommandProcessing</a> with <span class="extype" name="akka.actor.ActorLogging">ActorLogging</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@Aggregate[T]extendsActorwithCommandProcessingwithActorLogging" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate is the base actor class for aggregate commands.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate is the base actor class for aggregate commands. An
aggregate command is one that requires data for multiple keys,
and therefore must retrieve data from multiple Node actors - this
means that normal ClientNode -&gt; KeyNode -&gt; Node flow for a command
does not suffice. Each of these command generally have a
corresponding Aggregate subclass.</p><p>The flow of an aggregate command is one where a ClientNode creates
a temporary Aggregate actor that lives for the lifecycle of the
command being responded to - upon receiving a command, the Aggregate
actor breaks the command into the individual key/name/args
required per key, and sends these on the normal KeyNode -&gt; Node
flow, with the Aggregate actor itself being the Command destination
for the response, rather than a ClientNode. The Aggregate actor
knows how many responses it requires (usually given by the number of
keys/nodes it deals with), and once all nodes have responded, it
then constructs the command's Response to send back to the
ClientNode.</p><p>The construction of each Aggregate subclass takes a type parameter
specifying the response type it expects back from each Node, as well
as a command it will send to each Node it messages.</p><p>Various aspects of the aggregation flow can be controlled by
overriding methods.
</p></div></div>
    </li><li name="curiodb.AggregateBitOp" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregateBitOpextendsAggregate[scala.collection.mutable.BitSet]"></a>
      <a id="AggregateBitOp:AggregateBitOp"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateBitOp.html"><span class="name">AggregateBitOp</span></a><span class="result"> extends <a href="Aggregate.html" class="extype" name="curiodb.Aggregate">Aggregate</a>[<span class="extype" name="scala.collection.mutable.BitSet">BitSet</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateBitOpextendsAggregate[scala.collection.mutable.BitSet]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for the BITOP command.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for the BITOP command. Conceptually similar to
AggregateSetStore where the results are reduced then stored,
defering the final response to the Node being written to.
</p></div></div>
    </li><li name="curiodb.AggregateBroadcast" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AggregateBroadcast[T]extendsAggregate[T]"></a>
      <a id="AggregateBroadcast[T]:AggregateBroadcast[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateBroadcast.html"><span class="name">AggregateBroadcast</span></a><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <a href="Aggregate.html" class="extype" name="curiodb.Aggregate">Aggregate</a>[<span class="extype" name="curiodb.AggregateBroadcast.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateBroadcast[T]extendsAggregate[T]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Base Aggregate for all commands that need to communicate with *all*
KeyNode actors, namely PUBSUB with the CHANNELS subcommand, and each
of the commands that deal with the keyspace itself, namely
KEYS/SCAN/DBSIZE/RANDOMKEY/DEL/EXISTS/FLUSHDB/FLUSHALL.</p><div class="fullcomment"><div class="comment cmt"><p>Base Aggregate for all commands that need to communicate with *all*
KeyNode actors, namely PUBSUB with the CHANNELS subcommand, and each
of the commands that deal with the keyspace itself, namely
KEYS/SCAN/DBSIZE/RANDOMKEY/DEL/EXISTS/FLUSHDB/FLUSHALL.</p><p>As these commands don't deal with keys, define keys to means an
incremental integer, one for each KeyNode actor in the system.
</p></div></div>
    </li><li name="curiodb.AggregateCommands" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AggregateCommandsextendsCommandProcessing"></a>
      <a id="AggregateCommands:AggregateCommands"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="AggregateCommands.html"><span class="name">AggregateCommands</span></a><span class="result"> extends <a href="CommandProcessing.html" class="extype" name="curiodb.CommandProcessing">CommandProcessing</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateCommandsextendsCommandProcessing" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">AggregateCommands is exclusively part of ClientNode, but defined
separately here for clarity.</p><div class="fullcomment"><div class="comment cmt"><p>AggregateCommands is exclusively part of ClientNode, but defined
separately here for clarity. A ClientNode is responsible for
managing a single client connection, and handles certain commands
that don't go through the normal ClientNode -&gt; KeyNode -&gt; Node flow.
While some of these don't deal with Node actors at all, the bulk
are commands that must aggregate values from multiple Node actors,
which are all defined here. See the base Aggregate class for more
detail.
</p></div></div>
    </li><li name="curiodb.AggregateDBSize" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="AggregateDBSizeextendsBaseAggregateKeys"></a>
      <a id="AggregateDBSize:AggregateDBSize"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateDBSize.html"><span class="name">AggregateDBSize</span></a><span class="result"> extends <a href="BaseAggregateKeys.html" class="extype" name="curiodb.BaseAggregateKeys">BaseAggregateKeys</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateDBSizeextendsBaseAggregateKeys" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      
    </li><li name="curiodb.AggregateDel" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="AggregateDelextendsBaseAggregateBool"></a>
      <a id="AggregateDel:AggregateDel"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateDel.html"><span class="name">AggregateDel</span></a><span class="result"> extends <a href="BaseAggregateBool.html" class="extype" name="curiodb.BaseAggregateBool">BaseAggregateBool</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateDelextendsBaseAggregateBool" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for the DEL command.</p>
    </li><li name="curiodb.AggregateFlushAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregateFlushAllextendsAggregateSimpleReply"></a>
      <a id="AggregateFlushAll:AggregateFlushAll"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateFlushAll.html"><span class="name">AggregateFlushAll</span></a><span class="result"> extends <a href="AggregateSimpleReply.html" class="extype" name="curiodb.AggregateSimpleReply">AggregateSimpleReply</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateFlushAllextendsAggregateSimpleReply" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for the FLUSHALL command.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for the FLUSHALL command. It simply sends off the
corresponding internal command to all KeyNode actors.
</p></div></div>
    </li><li name="curiodb.AggregateFlushDB" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregateFlushDBextendsAggregateSimpleReply"></a>
      <a id="AggregateFlushDB:AggregateFlushDB"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateFlushDB.html"><span class="name">AggregateFlushDB</span></a><span class="result"> extends <a href="AggregateSimpleReply.html" class="extype" name="curiodb.AggregateSimpleReply">AggregateSimpleReply</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateFlushDBextendsAggregateSimpleReply" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for the FLUSHDB command.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for the FLUSHDB command. It simply sends off the
corresponding internal command to all KeyNode actors.
</p></div></div>
    </li><li name="curiodb.AggregateHyperLogLogCount" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregateHyperLogLogCountextendsAggregate[Long]"></a>
      <a id="AggregateHyperLogLogCount:AggregateHyperLogLogCount"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateHyperLogLogCount.html"><span class="name">AggregateHyperLogLogCount</span></a><span class="result"> extends <a href="Aggregate.html" class="extype" name="curiodb.Aggregate">Aggregate</a>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateHyperLogLogCountextendsAggregate[Long]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for the PFCOUNT command.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for the PFCOUNT command. Simpy runs HLL count on the Node
for each key given, and sums the results.
</p></div></div>
    </li><li name="curiodb.AggregateHyperLogLogMerge" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregateHyperLogLogMergeextendsAggregate[net.agkn.hll.HLL]"></a>
      <a id="AggregateHyperLogLogMerge:AggregateHyperLogLogMerge"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateHyperLogLogMerge.html"><span class="name">AggregateHyperLogLogMerge</span></a><span class="result"> extends <a href="Aggregate.html" class="extype" name="curiodb.Aggregate">Aggregate</a>[<span class="extype" name="net.agkn.hll.HLL">HLL</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateHyperLogLogMergeextendsAggregate[net.agkn.hll.HLL]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for the PFMERGE command.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for the PFMERGE command. Reduces each HLL with a union
operation, storing the final result in the Node for the given key.
</p></div></div>
    </li><li name="curiodb.AggregateKeys" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregateKeysextendsBaseAggregateKeys"></a>
      <a id="AggregateKeys:AggregateKeys"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateKeys.html"><span class="name">AggregateKeys</span></a><span class="result"> extends <a href="BaseAggregateKeys.html" class="extype" name="curiodb.BaseAggregateKeys">BaseAggregateKeys</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateKeysextendsBaseAggregateKeys" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for the KEYS command.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for the KEYS command. Simply combines all keys returned
</p></div></div>
    </li><li name="curiodb.AggregateMGet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregateMGetextendsAggregate[String]"></a>
      <a id="AggregateMGet:AggregateMGet"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateMGet.html"><span class="name">AggregateMGet</span></a><span class="result"> extends <a href="Aggregate.html" class="extype" name="curiodb.Aggregate">Aggregate</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateMGetextendsAggregate[String]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for the MGET command.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for the MGET command. Probably the simplest Aggregate as
it literally sends GET to each key, sending a list of responses
back to the ClientNode.
</p></div></div>
    </li><li name="curiodb.AggregateMSetNX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregateMSetNXextendsBaseAggregateBool"></a>
      <a id="AggregateMSetNX:AggregateMSetNX"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateMSetNX.html"><span class="name">AggregateMSetNX</span></a><span class="result"> extends <a href="BaseAggregateBool.html" class="extype" name="curiodb.BaseAggregateBool">BaseAggregateBool</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateMSetNXextendsBaseAggregateBool" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for the MSETNX command.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for the MSETNX command. We first query the KeyNode actors
for each key existing, and only send values to store in Node actors
if none of the keys exist, as per the MSETNX command's behavior.
</p></div></div>
    </li><li name="curiodb.AggregatePubSubChannels" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregatePubSubChannelsextendsAggregateBroadcast[Iterable[String]]"></a>
      <a id="AggregatePubSubChannels:AggregatePubSubChannels"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregatePubSubChannels.html"><span class="name">AggregatePubSubChannels</span></a><span class="result"> extends <a href="AggregateBroadcast.html" class="extype" name="curiodb.AggregateBroadcast">AggregateBroadcast</a>[<span class="extype" name="scala.Iterable">Iterable</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregatePubSubChannelsextendsAggregateBroadcast[Iterable[String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for the PUBSUB CHANNELS command/subcommand.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for the PUBSUB CHANNELS command/subcommand. Simply builds a
list of channels returned.
</p></div></div>
    </li><li name="curiodb.AggregatePubSubNumSub" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregatePubSubNumSubextendsAggregate[Int]"></a>
      <a id="AggregatePubSubNumSub:AggregatePubSubNumSub"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregatePubSubNumSub.html"><span class="name">AggregatePubSubNumSub</span></a><span class="result"> extends <a href="Aggregate.html" class="extype" name="curiodb.Aggregate">Aggregate</a>[<span class="extype" name="scala.Int">Int</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregatePubSubNumSubextendsAggregate[Int]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for the PUBSUB NUMSUB command/subcommand.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for the PUBSUB NUMSUB command/subcommand. This is a normal
Aggregate subclass that simply returns a list of responses.
</p></div></div>
    </li><li name="curiodb.AggregateRandomKey" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregateRandomKeyextendsAggregateBroadcast[String]"></a>
      <a id="AggregateRandomKey:AggregateRandomKey"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateRandomKey.html"><span class="name">AggregateRandomKey</span></a><span class="result"> extends <a href="AggregateBroadcast.html" class="extype" name="curiodb.AggregateBroadcast">AggregateBroadcast</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateRandomKeyextendsAggregateBroadcast[String]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for the RANDOMKEY command.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for the RANDOMKEY command. To avoid pulling down all keys,
each KeyNode has an internal _RANDOMKEY command, and we then draw
a random one of these.
</p></div></div>
    </li><li name="curiodb.AggregateScan" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregateScanextendsBaseAggregateKeys"></a>
      <a id="AggregateScan:AggregateScan"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateScan.html"><span class="name">AggregateScan</span></a><span class="result"> extends <a href="BaseAggregateKeys.html" class="extype" name="curiodb.BaseAggregateKeys">BaseAggregateKeys</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateScanextendsBaseAggregateKeys" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for the SCAN command.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for the SCAN command. Applies scan behavior in the same
way as the SSCAN/HSCAN/ZSCAN commands.
</p></div></div>
    </li><li name="curiodb.AggregateScriptExists" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="AggregateScriptExistsextendsAggregateBroadcast[Iterable[String]]"></a>
      <a id="AggregateScriptExists:AggregateScriptExists"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateScriptExists.html"><span class="name">AggregateScriptExists</span></a><span class="result"> extends <a href="AggregateBroadcast.html" class="extype" name="curiodb.AggregateBroadcast">AggregateBroadcast</a>[<span class="extype" name="scala.Iterable">Iterable</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateScriptExistsextendsAggregateBroadcast[Iterable[String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for the SCRIPT EXISTS command.</p>
    </li><li name="curiodb.AggregateSet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregateSetextendsBaseAggregateSet"></a>
      <a id="AggregateSet:AggregateSet"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateSet.html"><span class="name">AggregateSet</span></a><span class="result"> extends <a href="BaseAggregateSet.html" class="extype" name="curiodb.BaseAggregateSet">BaseAggregateSet</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateSetextendsBaseAggregateSet" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for all of the non-storing set commands, namely
SDIFF/SINTER/SUNION.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for all of the non-storing set commands, namely
SDIFF/SINTER/SUNION. It glues together the reducing operation with
the completion process.
</p></div></div>
    </li><li name="curiodb.AggregateSetReducer" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="AggregateSetReducer[T]extendsAggregate[T]"></a>
      <a id="AggregateSetReducer[T]:AggregateSetReducer[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateSetReducer.html"><span class="name">AggregateSetReducer</span></a><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <a href="Aggregate.html" class="extype" name="curiodb.Aggregate">Aggregate</a>[<span class="extype" name="curiodb.AggregateSetReducer.T">T</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateSetReducer[T]extendsAggregate[T]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Base Aggregate for all of the set operation commands, namely
SDIFF/SINTER/SUNION/SDIFFSTORE/SINTERSTORE/SUNIONSTORE.</p><div class="fullcomment"><div class="comment cmt"><p>Base Aggregate for all of the set operation commands, namely
SDIFF/SINTER/SUNION/SDIFFSTORE/SINTERSTORE/SUNIONSTORE. It
simply defines the set operation based on the command name, that
will be used in subclasses to reduce the results to a single set.
</p></div></div>
    </li><li name="curiodb.AggregateSetStore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregateSetStoreextendsBaseAggregateSet"></a>
      <a id="AggregateSetStore:AggregateSetStore"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateSetStore.html"><span class="name">AggregateSetStore</span></a><span class="result"> extends <a href="BaseAggregateSet.html" class="extype" name="curiodb.BaseAggregateSet">BaseAggregateSet</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateSetStoreextendsBaseAggregateSet" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for all of the storing set commands, namely
SDIFFSTORE/SINTERSTORE/SUNIONSTORE.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for all of the storing set commands, namely
SDIFFSTORE/SINTERSTORE/SUNIONSTORE. It overrides the completion
process to store the reduced results in the appropriate Node,
and abort sending a response which will be handled by the final
Node being written to.
</p></div></div>
    </li><li name="curiodb.AggregateSimpleReply" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="AggregateSimpleReplyextendsAggregateBroadcast[String]"></a>
      <a id="AggregateSimpleReply:AggregateSimpleReply"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateSimpleReply.html"><span class="name">AggregateSimpleReply</span></a><span class="result"> extends <a href="AggregateBroadcast.html" class="extype" name="curiodb.AggregateBroadcast">AggregateBroadcast</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateSimpleReplyextendsAggregateBroadcast[String]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Base Aggregate for commands that don't need data for a reply, namely
FLUSHDB/FLUSHALL.</p>
    </li><li name="curiodb.AggregateSortedSetStore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregateSortedSetStoreextendsAggregateSetReducer[com.dictiography.collections.IndexedTreeMap[String,Int]]"></a>
      <a id="AggregateSortedSetStore:AggregateSortedSetStore"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="AggregateSortedSetStore.html"><span class="name">AggregateSortedSetStore</span></a><span class="result"> extends <a href="AggregateSetReducer.html" class="extype" name="curiodb.AggregateSetReducer">AggregateSetReducer</a>[<span class="extype" name="com.dictiography.collections.IndexedTreeMap">IndexedTreeMap</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Int">Int</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@AggregateSortedSetStoreextendsAggregateSetReducer[com.dictiography.collections.IndexedTreeMap[String,Int]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Aggregate for all of the sorted set commands, namely
ZINTERSTORE/ZUNIONSTORE.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate for all of the sorted set commands, namely
ZINTERSTORE/ZUNIONSTORE. It is very different from its
AggregateSetStore counterpart, given the AGGREGATE/WEIGHTS
args it supports.
</p></div></div>
    </li><li name="curiodb.BaseAggregateBool" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="BaseAggregateBoolextendsAggregateBroadcast[Iterable[Boolean]]"></a>
      <a id="BaseAggregateBool:BaseAggregateBool"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="BaseAggregateBool.html"><span class="name">BaseAggregateBool</span></a><span class="result"> extends <a href="AggregateBroadcast.html" class="extype" name="curiodb.AggregateBroadcast">AggregateBroadcast</a>[<span class="extype" name="scala.Iterable">Iterable</span>[<span class="extype" name="scala.Boolean">Boolean</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@BaseAggregateBoolextendsAggregateBroadcast[Iterable[Boolean]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Base Aggregate for commands that deal with boolean responses from
each KeyNode actor, namely DEL/MSETNX.</p><div class="fullcomment"><div class="comment cmt"><p>Base Aggregate for commands that deal with boolean responses from
each KeyNode actor, namely DEL/MSETNX.</p><p>There are two ways this could be implemented, considering both
commands accept multiple keys, and we don't know which KeyNode
instances the keys belong to. The first approach, which we don't
use, would be to send individual messages per keys, each with a
single command and key - this would ensure each KeyNode only
receives the keys it manages, but would mean a large number of
messages given a large number of keys.</p><p>Instead we opt for a different approach which is an unintuitive
performance consideration - what we do is broadcast *all* keys
in the original command to *all* KeyNode instances. We can do this
because in each case (DEL/MSETNX) we're only interested in the
&quot;true&quot; values returned from each KeyNode, and these are only given
for valid keys (eg keys that belong to the KeyNode). So we get
a bunch of extraneous &quot;false&quot; values in the responses, for each key
that didn't actually belong to a KeyNode, but this does not affect
the final result for DEL/MSETNX. The end result here is that we
only send a message per KeyNode instead of a message per key,
which performs incredibly better, even though we send a ton of
redundant keys around.
</p></div></div>
    </li><li name="curiodb.BaseAggregateKeys" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="BaseAggregateKeysextendsAggregateBroadcast[Iterable[String]]"></a>
      <a id="BaseAggregateKeys:BaseAggregateKeys"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="BaseAggregateKeys.html"><span class="name">BaseAggregateKeys</span></a><span class="result"> extends <a href="AggregateBroadcast.html" class="extype" name="curiodb.AggregateBroadcast">AggregateBroadcast</a>[<span class="extype" name="scala.Iterable">Iterable</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@BaseAggregateKeysextendsAggregateBroadcast[Iterable[String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Base Aggregate for all commands that need to read lists of keys
from each KeyNode actor, namely KEYS/SCAN/DBSIZE.</p>
    </li><li name="curiodb.BaseAggregateSet" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="BaseAggregateSetextendsAggregateSetReducer[scala.collection.mutable.Set[String]]"></a>
      <a id="BaseAggregateSet:BaseAggregateSet"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="BaseAggregateSet.html"><span class="name">BaseAggregateSet</span></a><span class="result"> extends <a href="AggregateSetReducer.html" class="extype" name="curiodb.AggregateSetReducer">AggregateSetReducer</a>[<span class="extype" name="scala.collection.mutable.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@BaseAggregateSetextendsAggregateSetReducer[scala.collection.mutable.Set[String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Base Aggregate for all of the non-storing set commands, namely
SDIFF/SINTER/SUNION.</p><div class="fullcomment"><div class="comment cmt"><p>Base Aggregate for all of the non-storing set commands, namely
SDIFF/SINTER/SUNION. All it does is define the command used for
retrieving all members for each key, namely SMEMBERS.
</p></div></div>
    </li><li name="curiodb.BitmapNode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="BitmapNodeextendsNode[scala.collection.mutable.BitSet]"></a>
      <a id="BitmapNode:BitmapNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="BitmapNode.html"><span class="name">BitmapNode</span></a><span class="result"> extends <a href="Node.html" class="extype" name="curiodb.Node">Node</a>[<span class="extype" name="scala.collection.mutable.BitSet">BitSet</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@BitmapNodeextendsNode[scala.collection.mutable.BitSet]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Bitmap commands.</p><div class="fullcomment"><div class="comment cmt"><p>Bitmap commands. For simplicity the bitmap commands have their own
Node type which uses a BitSet for its underlying value.
</p></div></div>
    </li><li name="curiodb.CallArgs" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="CallArgsextendsProductwithSerializable"></a>
      <a id="CallArgs:CallArgs"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="CallArgs.html"><span class="name">CallArgs</span></a><span class="params">(<span name="args">args: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>, <span name="clientId">clientId: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@CallArgsextendsProductwithSerializable" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Args given to pcall/call functions inside a Lua script, that will be
used to construct a Command payload from a LuaClientNode actor.</p>
    </li><li name="curiodb.CallFunction" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="CallFunctionextendsVarArgFunction"></a>
      <a id="CallFunction:CallFunction"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="CallFunction.html"><span class="name">CallFunction</span></a><span class="result"> extends <span class="extype" name="org.luaj.vm2.lib.VarArgFunction">VarArgFunction</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@CallFunctionextendsVarArgFunction" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Lua API for pcall/call.</p><div class="fullcomment"><div class="comment cmt"><p>Lua API for pcall/call. When called, it takes the args provided,
constructs a CallArgs payload from them, creates a temporary
LuaClientNode actor and sends them to it using the ask pattern.
The raiseErrors arg marks the different behavior when a runtime Lua
error occurs via pcall/call - specifically whether a LuaError is
raised (as with call), or a message table containing the error is
returned (as with pcall).
</p></div></div>
    </li><li name="curiodb.ClientNode" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ClientNodeextendsNode[Null]withPubSubClientwithAggregateCommandswithScriptingClient"></a>
      <a id="ClientNode:ClientNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ClientNode.html"><span class="name">ClientNode</span></a><span class="result"> extends <a href="Node.html" class="extype" name="curiodb.Node">Node</a>[<span class="extype" name="scala.Null">Null</span>] with <a href="PubSubClient.html" class="extype" name="curiodb.PubSubClient">PubSubClient</a> with <a href="AggregateCommands.html" class="extype" name="curiodb.AggregateCommands">AggregateCommands</a> with <a href="ScriptingClient.html" class="extype" name="curiodb.ScriptingClient">ScriptingClient</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@ClientNodeextendsNode[Null]withPubSubClientwithAggregateCommandswithScriptingClient" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A ClientNode is a special type of Node in the system.</p><div class="fullcomment"><div class="comment cmt"><p>A ClientNode is a special type of Node in the system. It does not
represent any key/value provided by a client, but instead is
responsible for managing the life-cycle of a single client
connection.</p><p>ClientNode is subclassed according to each external protocol
supported, such as the Redis protocol over TCP, JSON over HTTP, and
also the Lua pcall/call scripting API. Each subclass is responsible
for converting its input into a Command payload, and converting
Response payloads back to the relevant protocol deal with.</p><p>ClientNode is a Node subclass, as it also handles certain commands
itself, such as utiilities that don't need to be routed via KeyNode
actors.
</p></div></div>
    </li><li name="curiodb.Command" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="CommandextendsProductwithSerializable"></a>
      <a id="Command:Command"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="Command.html"><span class="name">Command</span></a><span class="params">(<span name="input">input: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="scala.Any">Any</span>] = <span class="symbol">Seq()</span></span>, <span name="client">client: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="akka.actor.ActorRef">ActorRef</span>] = <span class="symbol">None</span></span>, <span name="db">db: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">&quot;0&quot;</span></span>, <span name="clientId">clientId: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">&quot;&quot;</span></span>, <span name="id">id: <span class="extype" name="scala.Predef.String">String</span> = <span class="defval" name="Random.alphanumeric.take(10).mkString">...</span></span>, <span name="createdInTransaction">createdInTransaction: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@CommandextendsProductwithSerializable" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Main payload for a command - stores its name, key, and args, and
contains utility methods for looking up attributes configured via
commands.conf.</p>
    </li><li name="curiodb.CommandProcessing" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="CommandProcessingextendsActor"></a>
      <a id="CommandProcessing:CommandProcessing"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="CommandProcessing.html"><span class="name">CommandProcessing</span></a><span class="result"> extends <span class="extype" name="akka.actor.Actor">Actor</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@CommandProcessingextendsActor" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Actor trait containing behavior for dealing with a Command - it
contains a command variable that the class should initially set upon
receiving it via the actor's receive method.</p><div class="fullcomment"><div class="comment cmt"><p>Actor trait containing behavior for dealing with a Command - it
contains a command variable that the class should initially set upon
receiving it via the actor's receive method. Used by anything that a
Command passes through, such as all ClientNode, KeyNode, Node, and
Aggregate actors.
</p></div></div>
    </li><li name="curiodb.ErrorReply" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ErrorReplyextendsProductwithSerializable"></a>
      <a id="ErrorReply:ErrorReply"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="ErrorReply.html"><span class="name">ErrorReply</span></a><span class="params">(<span name="message">message: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">&quot;syntax error&quot;</span></span>, <span name="prefix">prefix: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">&quot;ERR&quot;</span></span>)</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@ErrorReplyextendsProductwithSerializable" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">An error response, as per Redis protocol.</p>
    </li><li name="curiodb.HashNode" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="HashNodeextendsNode[scala.collection.mutable.Map[String,String]]"></a>
      <a id="HashNode:HashNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="HashNode.html"><span class="name">HashNode</span></a><span class="result"> extends <a href="Node.html" class="extype" name="curiodb.Node">Node</a>[<span class="extype" name="scala.collection.mutable.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@HashNodeextendsNode[scala.collection.mutable.Map[String,String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Hash commands.</p>
    </li><li name="curiodb.HttpClientNode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="HttpClientNodeextendsJsonClientNode"></a>
      <a id="HttpClientNode:HttpClientNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="HttpClientNode.html"><span class="name">HttpClientNode</span></a><span class="result"> extends <a href="JsonClientNode.html" class="extype" name="curiodb.JsonClientNode">JsonClientNode</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@HttpClientNodeextendsJsonClientNode" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">ClientNode that manages a single HTTP request - it extracts the JSON
args list from it and constructs a Command payload from them, and
then waits to receive back a Response payload, which it converts
back to JSON before returning it as a HTTP response.</p><div class="fullcomment"><div class="comment cmt"><p>ClientNode that manages a single HTTP request - it extracts the JSON
args list from it and constructs a Command payload from them, and
then waits to receive back a Response payload, which it converts
back to JSON before returning it as a HTTP response.</p><p>In the case of SUBSCRIBE/PSUBSCRIBE commands, state is changed into
a chunked mode which holds the connection open and can send multiple
PubSub messages back as chunked responses.
</p></div></div>
    </li><li name="curiodb.HttpServer" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="HttpServerextendsActor"></a>
      <a id="HttpServer:HttpServer"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="HttpServer.html"><span class="name">HttpServer</span></a><span class="result"> extends <span class="extype" name="akka.actor.Actor">Actor</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@HttpServerextendsActor" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Actor for the HTTP server that registers creation of a
HttpClientNode for each connection made.</p>
    </li><li name="curiodb.HyperLogLogNode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="HyperLogLogNodeextendsNode[net.agkn.hll.HLL]"></a>
      <a id="HyperLogLogNode:HyperLogLogNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="HyperLogLogNode.html"><span class="name">HyperLogLogNode</span></a><span class="result"> extends <a href="Node.html" class="extype" name="curiodb.Node">Node</a>[<span class="extype" name="net.agkn.hll.HLL">HLL</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@HyperLogLogNodeextendsNode[net.agkn.hll.HLL]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">HyperLogLog commands.</p><div class="fullcomment"><div class="comment cmt"><p>HyperLogLog commands. For simplicity the hyperloglog commands have
their own Node type which uses a net.agkn.hll.HLL for its underlying
value.
</p></div></div>
    </li><li name="curiodb.JsonClientNode" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="JsonClientNodeextendsClientNode"></a>
      <a id="JsonClientNode:JsonClientNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="JsonClientNode.html"><span class="name">JsonClientNode</span></a><span class="result"> extends <a href="ClientNode.html" class="extype" name="curiodb.ClientNode">ClientNode</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@JsonClientNodeextendsClientNode" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Base ClientNode for HTTP and WebSocket ClientNode actors - provides
methods for converting to/from JSON, and cleanup on disconnect.</p>
    </li><li name="curiodb.KeyNode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="KeyNodeextendsNode[scala.collection.mutable.Map[String,scala.collection.mutable.Map[String,curiodb.NodeEntry]]]withPubSubServerwithScriptingServer"></a>
      <a id="KeyNode:KeyNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="KeyNode.html"><span class="name">KeyNode</span></a><span class="result"> extends <a href="Node.html" class="extype" name="curiodb.Node">Node</a>[<span class="extype" name="scala.collection.mutable.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.collection.mutable.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <a href="NodeEntry.html" class="extype" name="curiodb.NodeEntry">NodeEntry</a>]]] with <a href="PubSubServer.html" class="extype" name="curiodb.PubSubServer">PubSubServer</a> with <a href="ScriptingServer.html" class="extype" name="curiodb.ScriptingServer">ScriptingServer</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@KeyNodeextendsNode[scala.collection.mutable.Map[String,scala.collection.mutable.Map[String,curiodb.NodeEntry]]]withPubSubServerwithScriptingServer" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A KeyNode is a special type of Node in the system.</p><div class="fullcomment"><div class="comment cmt"><p>A KeyNode is a special type of Node in the system. It does not
represent any key/value provided by a client, but instead is
responsible for managing the keyspace for a subset of keys in its
value field, which contains a map of DB names, mapped to keys,
mapped to nodes, where each node is represented by a NodeEntry.
KeyNode takes on the role of a Node, as there are a variety of
commands that logically belong to it.</p><p>When a ClientNode (the other special type of node, responsble
for handling a single client) receives a command for a particular
key, the command is first routed to the KeyNode responsible for that
key. The KeyNode maps each key to an ActorRef for the key's actual
node (StringNode, ListNode, etc), having first created the Node
actor at some point (this actually occurs when the key/node doesn't
exist and, a command is run that doesn't have a default defined, and
writes, as per in commands.conf), and forwards each command onto the
Node when received. The routing strategy used is configurable via
Akka (actor.deployment./keys.router in application.conf),
defaulting to the consistent-hashing-pool router.</p><p>A KeyNode also handles many commands itself that deal with key
management, such as deleting, persisting, and expiring keys.
Each NodeEntry instance stores a Option(Long/Cancellable) pair
which if expiring, contains the timestamp of when the expiry will
occur, and the Cancellable task that will actually run, deleting
the node. Deletion of a node (either via expiry or the DEL command)
simply sends a message to the Node actor which when received,
shuts down the actor, and then removes the key and NodeEntry from
the keyspace map.</p><p>Lastly worthy of discussion is a feature that Redis does not
provide, virtual memory, which simply allows a Node to persist
its value to disk, and shut down after a period of time (defined by
the curiodb.sleep-after duration value in reference.conf). The
difference between this occurring and a Node being deleted, is that
the key and NodeEntry is kept in the keyspace map. This is also why
the ActorRef for each Node in a NodeEntry is an Option - a value of
None indicates a sleeping Node. When a command is run against a key
mapped to a sleeping Node, a new Node actor is created, which will
read its previous value from disk. The idea here is to allow more
data to be stored in the system than can fit in memory.
</p></div></div>
    </li><li name="curiodb.ListNode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ListNodeextendsNode[scala.collection.mutable.ListBuffer[String]]"></a>
      <a id="ListNode:ListNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ListNode.html"><span class="name">ListNode</span></a><span class="result"> extends <a href="Node.html" class="extype" name="curiodb.Node">Node</a>[<span class="extype" name="scala.collection.mutable.ListBuffer">ListBuffer</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@ListNodeextendsNode[scala.collection.mutable.ListBuffer[String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">ListNode supports blocking commands (BLPOP, BRPOP, etc) where
if the list is empty, no immediate response is sent to the client,
and when the next command is run that adds to the list, we
essentially retry the original blocking command, and if we can
perform it (eg pop), we then send the requested value back to
the client.</p><div class="fullcomment"><div class="comment cmt"><p>ListNode supports blocking commands (BLPOP, BRPOP, etc) where
if the list is empty, no immediate response is sent to the client,
and when the next command is run that adds to the list, we
essentially retry the original blocking command, and if we can
perform it (eg pop), we then send the requested value back to
the client. This is implemented by storing an ordered set of
Command instances that are blocked, and iterating them each time the
next Command is received and processed. Timeouts are also supported
via the scheduler, which simply removes the blocked Command from the
set, and sends a null Response back to the ClientNode.
</p></div></div>
    </li><li name="curiodb.LogFuncton" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="LogFunctonextendsTwoArgFunction"></a>
      <a id="LogFuncton:LogFuncton"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="LogFuncton.html"><span class="name">LogFuncton</span></a><span class="result"> extends <span class="extype" name="org.luaj.vm2.lib.TwoArgFunction">TwoArgFunction</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@LogFunctonextendsTwoArgFunction" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Lua API for the log function.</p>
    </li><li name="curiodb.LuaClientNode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="LuaClientNodeextendsClientNode"></a>
      <a id="LuaClientNode:LuaClientNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="LuaClientNode.html"><span class="name">LuaClientNode</span></a><span class="result"> extends <a href="ClientNode.html" class="extype" name="curiodb.ClientNode">ClientNode</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@LuaClientNodeextendsClientNode" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">To implement call/pcall as synchronous functions, we need to use
Akka's ask pattern.</p><div class="fullcomment"><div class="comment cmt"><p>To implement call/pcall as synchronous functions, we need to use
Akka's ask pattern. Since each of the Node types only support
sending messages forwards (using tell), LuaClientNode is used as a
temporary actor that coordinates a command being run with the ask
pattern. It's also a ClientNode as it needs to construct Command
payloads from a sequence of args, in its case, those provided by the
pcall/call functions within a Lua script, and needs to be able to
perform the same commands a ClientNode can, such as SELECT/TIME/etc.</p><p>The ask flow is initiated when the LuaClientNode receives the
CallArgs payload, constructed from the pcall/call function args in
CallFunction below.
</p></div></div>
    </li><li name="curiodb.Node" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="Node[T]extendsPersistentActorwithCommandProcessingwithActorLogging"></a>
      <a id="Node[T]:Node[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="Node.html"><span class="name">Node</span></a><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <span class="extype" name="akka.persistence.PersistentActor">PersistentActor</span> with <a href="CommandProcessing.html" class="extype" name="curiodb.CommandProcessing">CommandProcessing</a> with <span class="extype" name="akka.actor.ActorLogging">ActorLogging</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@Node[T]extendsPersistentActorwithCommandProcessingwithActorLogging" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Node is the base actor class that all concrete node types subclass
Specifically, there is a concrete Node class for each data type
namely: StringNode for strings, HashNode for hashes, etc.</p><div class="fullcomment"><div class="comment cmt"><p>Node is the base actor class that all concrete node types subclass
Specifically, there is a concrete Node class for each data type
namely: StringNode for strings, HashNode for hashes, etc. There are
also some special Node types, such as KeyNode which manages the key
space for regular Node actors, and ClientNode which manages a single
client connection.</p><p>The base class here defines the core features of a Node actor,
namely:</p><ul><li>Its data value, typed by the type parameter that concrete
   subclasses must define.</li><li>Execution of the node's CommandRunner each time a Command is
   received.</li><li>Optionally persisting the node's value to disk (snapshotting)
   after a command has been handled (second point above), cleaning
   up older snapshots, and restoring from a snapshot on startup.</li></ul><p>Persistence warrants some discussion: we use akka-persistence, but
not completely, as event sourcing is not used, and we rely entirely
on its snapshotting feature, only ever keeping a single snapshot.
This was basically the easiest way to get persistence working.
We always store a reference to the last snapshot's meta-data (the
lastSnapshot var) so that we can delete old snapshots whenever a
new one is saved. As for saving, this is controlled via the config
var curiodb.persist-after which is the duration after which a
command runs that writes the node's value (described as writable in
the commands.conf file). When one of these commands runs, we call
save, which will schedule a Persist message back to the node itself.
This is based on the assumption that there's no guarantee an
actor's recieve and scheduler won't both execute at the exact same
time, so we have everything run through receive. The persisting
var stores whether persisting has been scheduled, to allow extra
save calls to do nothing when persisting has already been scheduled.
</p></div></div>
    </li><li name="curiodb.NodeEntry" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="NodeEntryextendsSerializablewithProduct"></a>
      <a id="NodeEntry:NodeEntry"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="NodeEntry.html"><span class="name">NodeEntry</span></a><span class="params">(<span name="kind">kind: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="node">node: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="akka.actor.ActorRef">ActorRef</span>] = <span class="symbol">None</span></span>, <span name="expiry">expiry: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="akka.actor.Cancellable">Cancellable</span>)] = <span class="symbol">None</span></span>, <span name="sleep">sleep: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="akka.actor.Cancellable">Cancellable</span>] = <span class="symbol">None</span></span>, <span name="deletedInTransaction">deletedInTransaction: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span> with <span class="extype" name="scala.Product">Product</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@NodeEntryextendsSerializablewithProduct" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A KeyNode manages a subset of keys, and stores these by mapping
DB names to keys to nodes, where nodes are represented by a
NodeEntry.</p><div class="fullcomment"><div class="comment cmt"><p>A KeyNode manages a subset of keys, and stores these by mapping
DB names to keys to nodes, where nodes are represented by a
NodeEntry.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@SerialVersionUID</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="curiodb.PubSubClient" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="PubSubClientextendsCommandProcessing"></a>
      <a id="PubSubClient:PubSubClient"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="PubSubClient.html"><span class="name">PubSubClient</span></a><span class="result"> extends <a href="CommandProcessing.html" class="extype" name="curiodb.CommandProcessing">CommandProcessing</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@PubSubClientextendsCommandProcessing" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">PubSubClient is exclusively part of ClientNode, but defined
separately here for clarity.</p><div class="fullcomment"><div class="comment cmt"><p>PubSubClient is exclusively part of ClientNode, but defined
separately here for clarity. A ClientNode is responsible for
managing a single client connection, and PubSubClient is
required to store a set of channels and patterns its subscribed
to, similar to the way PubSubServer maps these to ClientNode
ActorRef instances.</p></div></div>
    </li><li name="curiodb.PubSubEvent" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PubSubEventextendsProductwithSerializable"></a>
      <a id="PubSubEvent:PubSubEvent"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="PubSubEvent.html"><span class="name">PubSubEvent</span></a><span class="params">(<span name="event">event: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="channelOrPattern">channelOrPattern: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@PubSubEventextendsProductwithSerializable" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Message sent from PubSubServer/KeyNode to a PubSubClient/ClientNode
so that it can manage its own channel/pattern subscriptions.</p><div class="fullcomment"><div class="comment cmt"><p>Message sent from PubSubServer/KeyNode to a PubSubClient/ClientNode
so that it can manage its own channel/pattern subscriptions. See
PubSubServer for more detail.
</p></div></div>
    </li><li name="curiodb.PubSubServer" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="PubSubServerextendsCommandProcessing"></a>
      <a id="PubSubServer:PubSubServer"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="PubSubServer.html"><span class="name">PubSubServer</span></a><span class="result"> extends <a href="CommandProcessing.html" class="extype" name="curiodb.CommandProcessing">CommandProcessing</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@PubSubServerextendsCommandProcessing" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">PubSubServer is exclusively part of KeyNode, but defined separately
here for clarity.</p><div class="fullcomment"><div class="comment cmt"><p>PubSubServer is exclusively part of KeyNode, but defined separately
here for clarity. A KeyNode is responsible for managing the keyspace
for a subset of nodes, and therefore the same logic applies to pubsub
channels. A PubSubServer (KeyNode) stores channel names mapped to
ActorRef values for ClientNode actors (which have corresponding
PubSubClient traits, similar to the PubSubServer/KeyNode
relationship), which represent all client connections, pubsub or
otherwise).</p><p>A significant shortcoming in this design is handling for pattern
subscriptions. The problem is that a pattern may match channels
that are split across different KeyNode instances. To work around
this initially, we actually store *every* pattern subscription
on *every* KeyNode. Patterns are stored in the same way as channels,
with patterns mapped to ActorRef values for ClientNode actors.
</p></div></div>
    </li><li name="curiodb.ReplyFunction" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ReplyFunctionextendsOneArgFunction"></a>
      <a id="ReplyFunction:ReplyFunction"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ReplyFunction.html"><span class="name">ReplyFunction</span></a><span class="result"> extends <span class="extype" name="org.luaj.vm2.lib.OneArgFunction">OneArgFunction</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@ReplyFunctionextendsOneArgFunction" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Lua API for the status_reply/error_reply functions.</p><div class="fullcomment"><div class="comment cmt"><p>Lua API for the status_reply/error_reply functions. It just returns
a message table with the given key and message.
</p></div></div>
    </li><li name="curiodb.Response" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ResponseextendsProductwithSerializable"></a>
      <a id="Response:Response"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="Response.html"><span class="name">Response</span></a><span class="params">(<span name="value">value: <span class="extype" name="scala.Any">Any</span></span>, <span name="id">id: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@ResponseextendsProductwithSerializable" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Response a Node will return to a ClientNode after a command is run.</p><div class="fullcomment"><div class="comment cmt"><p>Response a Node will return to a ClientNode after a command is run.
Primarily used in CommandProcessing.
</p></div></div>
    </li><li name="curiodb.Routable" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="RoutableextendsConsistentHashingRouter.ConsistentHashablewithProductwithSerializable"></a>
      <a id="Routable:Routable"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="Routable.html"><span class="name">Routable</span></a><span class="params">(<span name="command">command: <a href="Command.html" class="extype" name="curiodb.Command">Command</a></span>)</span><span class="result"> extends <span class="extype" name="akka.routing.ConsistentHashingRouter.ConsistentHashable">ConsistentHashable</span> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@RoutableextendsConsistentHashingRouter.ConsistentHashablewithProductwithSerializable" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Command wrapper for routing it to its correct KeyNode.</p>
    </li><li name="curiodb.ScriptRunner" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ScriptRunnerextendsCommandProcessingwithActorLogging"></a>
      <a id="ScriptRunner:ScriptRunner"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="ScriptRunner.html"><span class="name">ScriptRunner</span></a><span class="result"> extends <a href="CommandProcessing.html" class="extype" name="curiodb.CommandProcessing">CommandProcessing</a> with <span class="extype" name="akka.actor.ActorLogging">ActorLogging</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@ScriptRunnerextendsCommandProcessingwithActorLogging" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Scripts stored via the SCRIPT LOAD command are stored in KeyNode
actors, and as such, scripts can be run from both KeyNode and
ClientNode actors (mixed in with the ScriptingServer and
ScriptingClient traits), via the EVALSHA and EVAL commands
respectively.</p><div class="fullcomment"><div class="comment cmt"><p>Scripts stored via the SCRIPT LOAD command are stored in KeyNode
actors, and as such, scripts can be run from both KeyNode and
ClientNode actors (mixed in with the ScriptingServer and
ScriptingClient traits), via the EVALSHA and EVAL commands
respectively. Given this, a temporary actor is required to run the
script, as it may make synchronous Lua calls to pcall/call, which
may result in a command running against the same KeyNode that's
running the script - this would fail since the running Lua script
would block the command from being run. So - ScriptRunner is merely
a temporary actor that runs a Lua script, which is initiated by
receiving the original Command payload it can then to respond to.
</p></div></div>
    </li><li name="curiodb.Scripting" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="ScriptingextendsCommandProcessingwithActorLogging"></a>
      <a id="Scripting:Scripting"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Scripting.html"><span class="name">Scripting</span></a><span class="result"> extends <a href="CommandProcessing.html" class="extype" name="curiodb.CommandProcessing">CommandProcessing</a> with <span class="extype" name="akka.actor.ActorLogging">ActorLogging</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@ScriptingextendsCommandProcessingwithActorLogging" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Base trait for both KeyNode and ClientNode actors that provides the
methods for compiling and running Lua scripts.</p>
    </li><li name="curiodb.ScriptingClient" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="ScriptingClientextendsScripting"></a>
      <a id="ScriptingClient:ScriptingClient"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="ScriptingClient.html"><span class="name">ScriptingClient</span></a><span class="result"> extends <a href="Scripting.html" class="extype" name="curiodb.Scripting">Scripting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@ScriptingClientextendsScripting" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">ClientNode mixin that can run scripts directly, or forward the
various LOAD subcommands onto the relevant KeyNode actor.</p>
    </li><li name="curiodb.ScriptingServer" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ScriptingServerextendsScripting"></a>
      <a id="ScriptingServer:ScriptingServer"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="ScriptingServer.html"><span class="name">ScriptingServer</span></a><span class="result"> extends <a href="Scripting.html" class="extype" name="curiodb.Scripting">Scripting</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@ScriptingServerextendsScripting" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">KeyNode mixin that stores compiled Lua scripts via the LOAD SCRIPT
command, and runs them via the EVALSHA command.</p><div class="fullcomment"><div class="comment cmt"><p>KeyNode mixin that stores compiled Lua scripts via the LOAD SCRIPT
command, and runs them via the EVALSHA command. In the same way
PubSub channels leverage the routing implemented for keys, the SHA1
of scripts mimic keys too for distribution.
</p></div></div>
    </li><li name="curiodb.SetNode" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="SetNodeextendsNode[scala.collection.mutable.Set[String]]"></a>
      <a id="SetNode:SetNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="SetNode.html"><span class="name">SetNode</span></a><span class="result"> extends <a href="Node.html" class="extype" name="curiodb.Node">Node</a>[<span class="extype" name="scala.collection.mutable.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@SetNodeextendsNode[scala.collection.mutable.Set[String]]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Set commands.</p>
    </li><li name="curiodb.SimpleReply" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="SimpleReplyextendsProductwithSerializable"></a>
      <a id="SimpleReply:SimpleReply"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="SimpleReply.html"><span class="name">SimpleReply</span></a><span class="params">(<span name="message">message: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">&quot;OK&quot;</span></span>)</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@SimpleReplyextendsProductwithSerializable" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A simple response, as per Redis protocol.</p>
    </li><li name="curiodb.SortedSetEntry" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SortedSetEntryextendsOrdered[curiodb.SortedSetEntry]withProductwithSerializable"></a>
      <a id="SortedSetEntry:SortedSetEntry"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="SortedSetEntry.html"><span class="name">SortedSetEntry</span></a><span class="params">(<span name="score">score: <span class="extype" name="scala.Float">Float</span></span>, <span name="key">key: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">&quot;&quot;</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ordering">ordering: <span class="extype" name="scala.Ordering">Ordering</span>[(<span class="extype" name="scala.Float">Float</span>, <span class="extype" name="scala.Predef.String">String</span>)]</span>)</span><span class="result"> extends <span class="extype" name="scala.Ordered">Ordered</span>[<a href="SortedSetEntry.html" class="extype" name="curiodb.SortedSetEntry">SortedSetEntry</a>] with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@SortedSetEntryextendsOrdered[curiodb.SortedSetEntry]withProductwithSerializable" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A SortedSetEntry is stored for each value in a SortedSetNode.</p><div class="fullcomment"><div class="comment cmt"><p>A SortedSetEntry is stored for each value in a SortedSetNode. It's
essentially a score/key pair which is Ordered.
</p></div></div>
    </li><li name="curiodb.SortedSetNode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SortedSetNodeextendsNode[(com.dictiography.collections.IndexedTreeMap[String,Float],com.dictiography.collections.IndexedTreeSet[curiodb.SortedSetEntry])]"></a>
      <a id="SortedSetNode:SortedSetNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="SortedSetNode.html"><span class="name">SortedSetNode</span></a><span class="result"> extends <a href="Node.html" class="extype" name="curiodb.Node">Node</a>[(<span class="extype" name="com.dictiography.collections.IndexedTreeMap">IndexedTreeMap</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Float">Float</span>], <span class="extype" name="com.dictiography.collections.IndexedTreeSet">IndexedTreeSet</span>[<a href="SortedSetEntry.html" class="extype" name="curiodb.SortedSetEntry">SortedSetEntry</a>])]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@SortedSetNodeextendsNode[(com.dictiography.collections.IndexedTreeMap[String,Float],com.dictiography.collections.IndexedTreeSet[curiodb.SortedSetEntry])]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Sorted sets are implemented slightly differently than in Redis.</p><div class="fullcomment"><div class="comment cmt"><p>Sorted sets are implemented slightly differently than in Redis. We
still use two data structures, but different ones than Redis does.
We use IndexedTreeMap to map keys to scores, and IndexedTreeSet to
map scores to keys. Both these are provided by the same third-party
library.</p><p>Like Redis, IndexedTreeMap is a map that maintains key order, but
also (unlike Java and Scala collections) supports indexing
(for range queries).</p><p>For scores mapped to keys, unlike Redis' skip list, we use
IndexedTreeSet which is an ordered set that also supports indexing.
We actually store both score and key (see SortedSetEntry above),
which provides ordering by score then by key.
</p></div></div>
    </li><li name="curiodb.StringNode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="StringNodeextendsNode[String]"></a>
      <a id="StringNode:StringNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="StringNode.html"><span class="name">StringNode</span></a><span class="result"> extends <a href="Node.html" class="extype" name="curiodb.Node">Node</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@StringNodeextendsNode[String]" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">String commands.</p><div class="fullcomment"><div class="comment cmt"><p>String commands. Note that unlike Redis, bitmap and HLL commands
have their own data types and corresponding classes, namely
BitmapNode and HyperLogLogNode.
</p></div></div>
    </li><li name="curiodb.TableGetnFunction" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="TableGetnFunctionextendsOneArgFunction"></a>
      <a id="TableGetnFunction:TableGetnFunction"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="TableGetnFunction.html"><span class="name">TableGetnFunction</span></a><span class="result"> extends <span class="extype" name="org.luaj.vm2.lib.OneArgFunction">OneArgFunction</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@TableGetnFunctionextendsOneArgFunction" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Lua API for the status_reply/error_reply functions.</p>
    </li><li name="curiodb.TcpClientNode" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="TcpClientNodeextendsClientNode"></a>
      <a id="TcpClientNode:TcpClientNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="TcpClientNode.html"><span class="name">TcpClientNode</span></a><span class="result"> extends <a href="ClientNode.html" class="extype" name="curiodb.ClientNode">ClientNode</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@TcpClientNodeextendsClientNode" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">ClientNode that manages a single TCP connection - it buffers
data received in the Redis protocol, until it contains a complete
packet it can construct a Command payload with.</p>
    </li><li name="curiodb.TcpServer" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="TcpServerextendsActor"></a>
      <a id="TcpServer:TcpServer"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="TcpServer.html"><span class="name">TcpServer</span></a><span class="result"> extends <span class="extype" name="akka.actor.Actor">Actor</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@TcpServerextendsActor" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Actor for the TCP server that registers creation of a TcpClientNode
for each connection made.</p>
    </li><li name="curiodb.TransactionAck" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TransactionAckextendsProductwithSerializable"></a>
      <a id="TransactionAck:TransactionAck"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="TransactionAck.html"><span class="name">TransactionAck</span></a><span class="params">(<span name="keyCount">keyCount: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>)</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@TransactionAckextendsProductwithSerializable" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Message that a Node or KeyNode actor sends back to a ClientNode
actor to acknowledge the number of keys it has dealt with after
receiving _MULTI or _EXEC commands.</p><div class="fullcomment"><div class="comment cmt"><p>Message that a Node or KeyNode actor sends back to a ClientNode
actor to acknowledge the number of keys it has dealt with after
receiving _MULTI or _EXEC commands.
See ClientNode.awaitTransactionAcks for more detail.
</p></div></div>
    </li><li name="curiodb.WebSocketClientNode" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="WebSocketClientNodeextendsJsonClientNodewithWebSocketServerWorker"></a>
      <a id="WebSocketClientNode:WebSocketClientNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="WebSocketClientNode.html"><span class="name">WebSocketClientNode</span></a><span class="result"> extends <a href="JsonClientNode.html" class="extype" name="curiodb.JsonClientNode">JsonClientNode</a> with <span class="extype" name="spray.can.websocket.WebSocketServerWorker">WebSocketServerWorker</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@WebSocketClientNodeextendsJsonClientNodewithWebSocketServerWorker" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      
    </li><li name="curiodb.WebSocketServer" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="WebSocketServerextendsActor"></a>
      <a id="WebSocketServer:WebSocketServer"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="WebSocketServer.html"><span class="name">WebSocketServer</span></a><span class="result"> extends <span class="extype" name="akka.actor.Actor">Actor</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@WebSocketServerextendsActor" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Actor for the WebSocket server that registers creation of a
WebSocketClientNode for each connection made.</p>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="curiodb.Attributes" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Attributes"></a>
      <a id="Attributes:Attributes"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Attributes$.html"><span class="name">Attributes</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@Attributes" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Loads all of the command attributes from commands.conf into a
structure (command names mapped to maps of attribute names/values)
that Command instances can use to look up their configured
attributes.</p>
    </li><li name="curiodb.Coerce" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Coerce"></a>
      <a id="Coerce:Coerce"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Coerce$.html"><span class="name">Coerce</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@Coerce" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Utilities for converting between Lua and JVM values.</p><div class="fullcomment"><div class="comment cmt"><p>Utilities for converting between Lua and JVM values. Handles manual
conversion between Seq and LuaValue, as well as conversion between
ErrorReply/SimpleReply and Lua tables (or message tables).
</p></div></div>
    </li><li name="curiodb.CurioDB" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="CurioDB"></a>
      <a id="CurioDB:CurioDB"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="CurioDB$.html"><span class="name">CurioDB</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@CurioDB" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Entry point for the system.</p><div class="fullcomment"><div class="comment cmt"><p>Entry point for the system. It configures Akka clustering, and
starts the TCP and HTTP servers once the cluster has formed.</p><p>Currently the number of nodes (instances of the program, not Node
actors) in the cluster is fixed in size, given the config value
curiodb.nodes, eg:</p><pre>curoidb.nodes = {
  node1: <span class="lit">"tcp://127.0.0.1:9001"</span>
  node2: <span class="lit">"tcp://127.0.0.1:9002"</span>
  node3: <span class="lit">"tcp://127.0.0.1:9003"</span>
}</pre><p>We then use this value to configure the various akka.cluster
config values. One of the main future goals is to explore
Akka's cluster sharding package, which should allow for more
dynamic topologies.
</p></div></div>
    </li><li name="curiodb.Delete" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Delete"></a>
      <a id="Delete:Delete"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Delete$.html"><span class="name">Delete</span></a><span class="result"> extends <span class="extype" name="akka.dispatch.ControlMessage">ControlMessage</span> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@Delete" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Message that shuts a Node actor down and delete its value from disk.</p>
    </li><li name="curiodb.LogLevel" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="LogLevel"></a>
      <a id="LogLevel:LogLevel"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="LogLevel$.html"><span class="name">LogLevel</span></a><span class="result"> extends <span class="extype" name="scala.Enumeration">Enumeration</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@LogLevel" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Log levels.</p>
    </li><li name="curiodb.Persist" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Persist"></a>
      <a id="Persist:Persist"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Persist$.html"><span class="name">Persist</span></a><span class="result"> extends <span class="extype" name="akka.dispatch.ControlMessage">ControlMessage</span> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@Persist" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Message that a Node actor sends to itself when it's ready to save
its value to disk.</p><div class="fullcomment"><div class="comment cmt"><p>Message that a Node actor sends to itself when it's ready to save
its value to disk. See Node.save() for more detail.
</p></div></div>
    </li><li name="curiodb.Sleep" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Sleep"></a>
      <a id="Sleep:Sleep"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Sleep$.html"><span class="name">Sleep</span></a><span class="result"> extends <span class="extype" name="akka.dispatch.ControlMessage">ControlMessage</span> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#curiodb.package@Sleep" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Message that tells an actor to shut down, but not delete its value
from disk - the KeyNode holding its key still contains a reference
to it, and a new actor will be started for it the next time a
command is received for its key.</p><div class="fullcomment"><div class="comment cmt"><p>Message that tells an actor to shut down, but not delete its value
from disk - the KeyNode holding its key still contains a reference
to it, and a new actor will be started for it the next time a
command is received for its key. See KeyNode for more detail.
</p></div></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>
